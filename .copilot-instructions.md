# GitHub Copilot Instructions

## Project Description
This is an e-commerce website built with Next.js and TypeScript that supports:
- Generic CMS pages with generic sections which get data from Wordpress rest api
- Woocommerce integration as headless CMS to support products, categories, orders, and auth
- In future i also want to add: 
  - Ga4 analytics
  - sentry error tracking
  - test with vitest and react-testing-library

## Project Architecture

### Folder Structure
- `src/app/` - Next.js App Router with dynamic routes
- `src/features/` - Business features (e.g., header, menu)
- `src/shared/` - Shared components, actions, types
- `src/views/` - Page views with business logic

### Architecture Patterns
- **Feature-based organization** - each feature has its own folder
- **Server Actions** - use files in `actions/` folders for server logic
- **Component co-location** - components with their types and actions in the same folder
- **Barrel exports** - use `index.ts` files for re-exports, but only when it improves import paths
- **Separation of concerns** - separate UI components, data fetching, and business logic
- **Folder structure rule** - features can be import only in app or views, shared can be imported everywhere, and only from index.ts files

## Coding Conventions

### TypeScript
- Always use strict TypeScript
- Define types in `types/index.ts` files
- Use interfaces for objects, type aliases for unions/primitives
- Export types with `type` prefix in imports

### React/Next.js
- Use Server Components as default
- Client Components only when needed (interactions, hooks)
- Async Server Components for API calls
- Dynamic imports for heavy components

### Styling
- Tailwind CSS for styling
- Shadcn/ui for UI components

### Naming Conventions
- Components: PascalCase (e.g., `ProductsList`)
- Component files: PascalCase (e.g., `ProductsList/index.tsx`)
- Functions/variables: camelCase
- Server actions: camelCase with prefix (e.g., `getProductsData`)
- Types: PascalCase with descriptive suffix (e.g., `ProductsListProps`)

## Implementation Patterns

### Server Actions with Error Handling
```typescript
// src/shared/actions/getProductsData.ts
export const getProductsData = async (categoryId?: string) => {
    try {
    //implementation
  } catch (error) {
    console.error('Error fetching data:', error);
    throw new Error('Failed to fetch data');
  }
}
```

### Components
```typescript
// src/shared/components/ProductsList/index.tsx
interface ProductsListProps {
  products: Product[];
  className?: string;
}

const ProductsList = ({ products, className }: ProductsListProps) => {
  // Implementation
}

export default ProductsList;
```

### Page Views
```typescript
// src/views/generic-page-view/index.tsx
interface GenericPageViewProps {
  slug: string;
}

const GenericPageView = async ({ slug }: GenericPageViewProps) => {
  const pageData = await getGenericPageDataByUrl(slug);
  // Implementation
}

export default GenericPageView;
```

### Dynamic Routes
- `[[...genericPageSlug]]` for catch-all routes
- `[categorySlug]` for parametric routes

## External Integrations

### WordPress API
- Use axios from configuration in `src/shared/lib/axios.ts`
- All API calls in `actions/` folders
- Error handling and loading states

### Shadcn/ui
- Components in `src/shared/lib/shadcn/`
- Customization through Tailwind CSS
- Use components according to design system

## Best Practices

### Performance
- Lazy loading for heavy components
- Image optimization with next/image
- Server-side rendering as default
- Client hydration only when needed

### SEO
- Next.js Metadata API for SEO
- Structured data for products
- Proper heading hierarchy (h1, h2, h3...)

### Accessibility
- Semantic HTML
- ARIA labels where needed
- Keyboard navigation support
- Screen reader friendly

### Error Handling
- Error boundaries for components
- Graceful degradation
- User-friendly error messages
- Proper loading states

## Commit Message Convention

Follow this format for consistent and informative commit messages:

### Format
```
<type><icon>: <short description>

<optional longer description>
<optional breaking changes>
```

### Types and Icons
- `featâœ¨` - new feature
- `fixğŸ›` - bug fix
- `refactorâ™»ï¸` - code refactoring (no functional changes)
- `styleğŸ’„` - formatting, styling changes
- `perfâš¡` - performance improvements
- `docsğŸ“` - documentation changes
- `testğŸ§ª` - adding or updating tests
- `choreğŸ”§` - maintenance tasks, deps updates
- `ciğŸ‘·` - CI/CD pipeline changes
- `buildğŸ“¦` - build system changes

### Examples

**Good examples:**
```bash
featâœ¨: add product filtering by category

- Add category filter dropdown to products page
- Implement server-side filtering logic
- Update ProductsList component to handle filtered results

fixğŸ›: resolve header menu not closing on mobile

refactorâ™»ï¸: convert type declarations to interfaces

- Improve TypeScript error messages
- Enable better interface extension
- Follow React/TypeScript best practices

styleğŸ’„: update button hover states and spacing

perfâš¡: optimize product images loading with next/image

docsğŸ“: update README with deployment instructions

choreğŸ”§: update dependencies to latest versions
```

**Bad examples:**
```bash
// âŒ Too vague
fix: stuff

// âŒ No icon/type
update header component

// âŒ Too long subject line
feat: add very long description that explains everything in the subject line which should be in the body instead
```

### Rules
1. **Subject line**: max 50 characters
2. **Use present tense**: "add" not "added"
3. **No period** at the end of subject line
4. **Body**: explain what and why, not how
5. **Separate** subject from body with blank line

## Guidelines for Copilot

1. **Always check existing patterns** before implementation
2. **Use TypeScript** - don't skip types
3. **Follow folder structure** - place files in appropriate locations
4. **Server-first approach** - use Server Components when possible
5. **Reuse existing components** - check `src/shared/components/` before creating new ones
6. **Consistent naming** - follow established naming conventions
7. **Error handling** - always handle errors and loading states
8. **Accessibility** - remember accessibility in every component